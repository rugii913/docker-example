# Docker, Kubernetes 예제

## 준비
### Docker 설치
- [docker docs 공식 문서](https://docs.docker.com/)
  - [Windows용 Docker Desktop 설치](https://docs.docker.com/desktop/install/windows-install/)
    - [Windows WSL 설치 방법](https://learn.microsoft.com/en-us/windows/wsl/install)
      - [Docker Desktop WSL 2 backend on Windows](https://docs.docker.com/desktop/wsl/)
    - [Windows Hyper-V 관련](https://docs.docker.com/desktop/troubleshoot/topics/#virtualization)
      - [Hyper-V 관련 설명](https://learn.microsoft.com/en-us/windows-server/virtualization/hyper-v/hyper-v-technology-overview)
    - [Windows에서 Docker 권한 문제 관련](https://docs.docker.com/desktop/windows/permission-requirements/)
- [WSL 2에서 Docker 원격 컨테이너 시작](https://learn.microsoft.com/ko-kr/windows/wsl/tutorials/wsl-containers)
- [WSL 2에 직접 Docker 설치하기\(네이버 블로그 참고\)](https://blog.naver.com/ilikebigmac/222007741507)
  - 굳이 이 블로그 글을 보기보다는 Docker 공식 문서 Install Docker Engine on Ubuntu 부분을 참고하면 될 듯

### VSCode 설정
- (확장) Docker, Prettier 등

### Docker 살펴보기
- [reference documentation](https://docs.docker.com/reference/)
  - [CLI reference](https://docs.docker.com/reference/cli/docker/)
  - [Develop with Docker Engine API](https://docs.docker.com/engine/api/)
- [Overview of Docker Desktop](https://docs.docker.com/desktop/)
  - Docker Desktop은 Docker Engine, Docker CLI client, Docker Scout, Docker Build, Docker Extensions, Docker Compose, Docker Content Trust, Kubernetes, Credential  Helper를 포함
  - Docker Engine은 애플리케이션을 빌드하고 컨테이너라이즈하는 컨테이너 기술
  - Docker Scout는 vulnerability에 대한 chain security 강화를 위한 것 [Docker Scout](https://docs.docker.com/scout/)
  - Docker Build는 image 만들기, 코드 패키징 등을 위한 것 [Overview of Docker Build](https://docs.docker.com/build/)
  - Docker Compose multi-container 애플리케이션을 정의하고 실행하기 위한 도구 [Docker Compose overview](https://docs.docker.com/compose/)
- [Docker Engine overview](https://docs.docker.com/engine/)
  - Docker Engine은 client-server 애플리케이션과 같이 동작함
    - dockerd가 daemon process인 server 역할
    - 프로그램들이 daemon과 소통할 수 있는 인터페이스인 APIs
    - docker는 CLI client 역할
      - CLI가 daemon과 상호작용하기 위해 스크립트 혹은 CLI 직접 명령을 통해 Docker APIs를 이용
  - Docker daemon 관련 참고
    - [Windows의 Docker 엔진](https://learn.microsoft.com/ko-kr/virtualization/windowscontainers/manage-docker/configure-docker-daemon)
    - [Start the daemon](https://docs.docker.com/config/daemon/start/)
    - Windows에서는 dockerd 명령어를 통해 Docker daemon을 실행할 수 없는 것으로 알고 있음
    - 하지만 C:\ProgramData\Docker\config\daemon.json 파일을 이용해 Docker daemon 구성을 변경할 수는 있음
  - [Install Docker Engine](https://docs.docker.com/engine/install/) Linex에서 Docker를 사용하고자 한다면 Docker Engine을 설치
    - [Install Docker Engine on Ubuntu](https://docs.docker.com/engine/install/ubuntu/)

## 핵심 정리
### image
- 핵심
  - 애플리케이션 코드와 이를 실행하는 데 필요한 도구, 설정 포함
  - container의 템플릿, 청사진
- 특성
  - layer based architecture
    - Dockerfile의 모든 명령이 image context의 각 layer를 나타냄
    - image 빌드 시 Docker는 모든 명령 결과을 cache, 다시 실행할 필요가 없는 것으로 판단된 명령은 cache된 결과를 사용
    - 변경이 있을 경우 모든 후속 layer에 대해서 캐시 결과를 사용하지 않음
  - read-only
    - 명령이 실행되고 image가 빌드되면 image의 code를 변경할 수 없음
    - 변경이 필요하면 새로운 image 빌드
- image 정보 검사(inspect)
  - docker image inspect \[image id 혹은 image repository 이름\]로 image의 정보 확인 가능
  - image의 full id, 생성 시간, container 구성 정보(노출 포트, 환경 변수, entry point, 사용 OS, layer들 등등)
- image tags
  - name:tag로 구성, name은 repository라고도 함 ex. redis:latest
    - name과 tag를 결합해 unique identifier로 기능함
    - name은 image의 일반적인 이름, 특정 image group을 정의
    - tag는 위 name으로 형성된 특정 image group에서 특정 image를 정의 → 특정 version처럼 사용
### container
- 핵심
  - 소프트웨어 실행 단위 - 애플리케이션과 실행 환경을 포함하는 작은 패키지
  - image의 구체적인 실행 인스턴스
  - container 실행 시 image layer 위에 새로운 container layer를 추가
    - container는 image 위에 추가된 얇은 명령 layer → 실행 중인 container의 size(용량)은 그리 크지 않음
    - 동일한 image를 기반으로 실행되는 여러 container는 image 내부 코드를 공유
- lifecycle
  - 참고 [Lifecycle of Docker Container](https://medium.com/@BeNitinAgarwal/lifecycle-of-docker-container-d2da9f85959)
- attached 모드, detached 모드
  - attached(연결) 모드
    - container를 foreground에서 실행 (cf. docker run으로 실행할 경우 attached 모드가 디폴트)
    - container의 출력 결과를 수신(attach to STDIN, STDOUT or STDERR)
  - detached(분리) 모드
    - container를 background에서 실행 (cf. docker start로 실행할 경우 detached 모드가 디폴트)
- interactive 모드
  - container와 container로 실행 중인 app이 상호작용할 수 있는 모드
  - STDIN을 open으로 유지, attached 모드가 아니어도 상관 없음
  - 주로 pseudo-TTY를 할당하여 터미널을 생성하는 옵션과 함께 실행
### Dockerfile
- 자체 이미지를 빌드할 때 실행하려는 명령이 있는 파일
  - Dockerfile의 각 명령이 image context의 각 layer가 됨
- Dockerfile 작성
  - image 빌드 시 cache를 사용하도록 명령 순서 최적화 필요
  - \(1\) base image 지정
    - FROM [image 이름] → ex .FROM node
    - 보통 Docker 파일 첫 줄이 됨
    - 다른 base image 위에 커스텀 이미지를 구축 ex. OS layer , runtime 환경 같은 것들
    - 로컬 시스템에 있는 image 혹은 Docker Hub 등 registry에 있는 image 이름을 명시
  - \(2\) 작업 경로 지정
    - WORKDIR \[path\] → ex. WORKDIR /app
    - 모든 후속 명령도 해당 경로에서 실행
  - \(3\) 로컬 머신에 있는 파일 복사
    - COPY \[image의 외부 path\] \[path2\] → ex. COPY . ./
      - 첫번째 . → Dockerfile이 위치한 현재 경로를 기준으로 모든 디렉토리, 파일(하위 디렉토리, 파일 포함)을 복사, Dockerfile 자체는 포함하지 않음
      - 두번째 ./
        - 복사한 파일을 저장할 image 내부의 경로, image 및 container는 기본적으로 로컬 머신의 파일 시스템과 완전히 분리된 container 내부 파일 시스템을 가짐
        - ./ 으로 작성하면 WORKDIR로 지정된 경로에 복사, /app으로 명시적으로 작성할 수도 있음
    - image 빌드 시 cache 사용을 위해 일부 파일만 먼저 COPY 하도록 최적화 가능 → ex. COPY package.json /app
  - \(4\) 애플리케이션 빌드, 패키지 설정 등 작업을 위한 image 생성 시 필요 명령 작성
    - RUN \[명령어\]
      - ex. RUN npm install - cf. 시간이 오래 걸리는 작업은 Dockerfile 명령어 순서를 조정하여 cache를 사용할 수 있도록 최적화 필요
  - \(5\) 로컬 시스템과 통신할 포트 설정
    - EXPOSE [포트 번호 숫자] → ex. EXPOSE 80
    - CMD 명령보다 앞에 있어야 함
    - **EXPOSE 유의사항**
      - [Dockerfile reference- EXPOSE](https://docs.docker.com/reference/dockerfile/#expose)
      - EXPOSE: Describe which ports your application is listening on.
      - The EXPOSE instruction doesn't actually publish the port. ... Regardless of the EXPOSE settings, you can override them at runtime by using the -p flag.
      - EXPOSE는 문서화할 뿐임,  실제 포트 노출은 docker run -p 옵션을 통해 진행됨
  - \(6\) image를 바탕으로 container 시작 시 필요 명령 작성
    - CMD \[명령어를 위한 문자열 배열\] → ex. CMD \["node", "server.js"\]
    - CMD가 없는 경우 단지 base image가 실행됨
- Dockerfile 기반으로 커스텀 image 생성
  - docker build [Dockerfile이 있는 경로] → ex. docker build .
- 빌드된 커스텀 image를 container로 실행
  - docker run -p \[로컬 포트\]:\[container 노출 포트\] \[image 이름\]
    - container 노출 포트는 image에서 EXPOSE로 노출한 포트
    - cf. -p는 publish(게시)를 의미
### image 공유
- container를 공유하지 않고 image를 공유, 공유된 image를 기반으로 container를 실행
- cf. Dockerfile 공유
  - Dockerfile과 함께 app의 source code를 제공, 공유된 파일을 이용해 image 빌드
  - Dockerfile의 위치를 중심으로 모든 파일과 디렉토리 구조까지 공유되어야 함
- 빌드된 image 공유
  - image를 다운(pull)받고 container를 실행하기만 하면 됨
  - image 자체를 공유할 때는 1. Docker Hub 혹은 2. Private Registry 이용
- registry: image 공유 위치
  - (1) Docker Hub: official Docker image registry
    - public, private, offical image들 존재
  - (2) private registry: Docker Hub 외에도 다양한 provider 존재
- 빌드된 image 공유 방법
  - (공유 시) docker push \[image 이름\]
  - (사용 시) docker pull \[image 이름\]
  - 공유를 위해선 먼저 registry에 image의 repository를 생성해두어야 함
    - registry의 repository와 일치하는 이름을 가진 local registry가 있어야 함
    - 즉 image의 이름이 registry repository와 같은 image가 있어야 함
  - private registry에서 image를 공유하고자 할 경우 \[provider url:image 이름\]과 같은 방식으로 host까지 명시해줘야 함
  - 참고 사항
    - push 할 때는 의존하고 있는 base image까지 함께 업로드하지 않음
      - base image에 대한 연결을 설정하고, 추가 정보만 push
    - tag를 명시하지 않으면 latest tag를 자동으로 부여

## Docker CLI 주요 명령어 및 그 옵션
- --help
  - (모든 Docker CLI 명령어 확인) docker --help
    - cf. 예전에 사용했으나, 현재는 더 나은 명령어가 나왔기에 거의 사용할 일이 없는 명렁어도 있음
  - (특정 명령어의 옵션 확인) docker \[명령어\] --help → 해당 명령어에 대한 모든 옵션 확인
- push → image 업로드
  - (사용 방법) docker push \[image 이름\]
    - (private registry를 사용할 경우) docker push \[provider url:image 이름\]
- push → image 다운로드
  - (사용 방법) docker pull \[image 이름\]
    - (private registry를 사용할 경우) docker pull \[provider url:image 이름\]
- build → Dockerfile을 기반으로 image 빌드
  - (사용 방법) docker build .
  - \(-t flag 혹은 --tag \[list\]\) 빌드할 image에 name:tag 형식으로 image tag 부여
    - ex. docker build -t goals:1 .
  - cf. 만약 이미 존재하는 image의 이름을 변경하고자 한다면 tag 명령어를 사용
- tag → 이미 존재하는 image의 image tag(image 이름, repository)를 변경
  - (사용 방법) docker tag \[image의 현재 이름\] \[변경하고자 하는 이름\]
  - cf. 이전 image는 제거되지 않고, 변경된 이름을 가진 복제본 생성
- login → registry에 로그인
  - (사용 방법) docker login 입력 후 프롬프트에 따라 Username, Password 입력
    - (옵션을 이용해 Username, Password 입력) docker login -u \[Username\] -p \[Password\]
    - (다른 registry에 로그인할 경우) docker login \[registry url\]
  - cf. docker logout으로 registry에서 로그아웃 가능
- run
  - (사용 방법) docker run \[image name\] → image를 기반으로 새 컨테이너를 생성
    - run으로 다른 옵션 없이 container을 생성 및 시작할 경우 attached - 터미널에서 blocked(foreground 실행)
    - 이 상태에서 ctrl + c를 입력할 경우 status가 Exited가 됨
    cf. local에 image가 없는 경우 registry에서 자동으로 pull → image가 있다면 image를 업데이트하진 않는다는 의미이기도 함
  - \(-p flag 혹은 --publish \[list\]\) 로컬 머신의 어떤 포트가 container의 특정 포트에 접근하는데 사용되는지 명시 
    - -p \[app에 접근하려는 로컬 포트\]:[내부 container 노출 포트] → ex. -p 3000:80
  - \(-d flag\) detached 모드로 실행
  - \(-i flag 혹은 --interactive\) open STDIN - interactive 모드로 실행
  - \(-t flag 혹은 --tty\) pseudo-TTY 할당
  - \(--rm flag) container를 중지할 때 제거되도록 함
  - \(--name flag \[string\]) container에 이름을 부여
- start
  - (사용 방법) docker start \[container name 혹은 containter id\] → status가 Exited인 container를 다시 시작
    - start로 다른 옵션 없이 재시작할 경우 detached - 터미널에서 blocking하지 않음(background 실행)
  - \(-a flag\) attached 모드로 실행 → STDOUT/STDERR와 연결하는 것
    - 이 상태에서 ctrl + c를 입력할 경우 status가 Exited가 되지 않고 Up으로 계속 실행
  - \(-i flag 혹은 --interactive\) open STDIN
    - docker start d-ai .. 로 container에 attached되며 interactive 작업 가능해짐
- attach
  - (사용 방법) docker attach \[container name 혹은 containter id\] → detached 모드로 시작된 container에 attach
    - 이 상태에서 ctrl + c를 입력할 경우 status가 Exited가 됨
- logs
  - (사용 방법) docker logs \[container name 혹은 containter id\] → 해당 container의 로그 확인
  - \(-f flag 혹은 --follow\) Follow log output - 로그 출력 수신 대기, 앞으로 출력되는 로그도 확인하도록 연결
- rm → containter를 제거
  - (사용 방법) docker rm \[container name 혹은 containter id\]
    - 다음과 같이 여러 container를 한 번에 제거할 수도 있음
    - docker rm \[container name 혹은 containter id\] \[container name 혹은 containter id\] ...
    - 실행 중인 container는 기본 rm으로 제거 불가능, stop 후 제거 가능
  - cf. container prune → 중지된 모든 container를 제거
    - (사용 방법) docker container prune
    - cf. docker prune으로는 실행할 수 없음, management command인 container를 꼭 붙여야 함
- rmi → image를 제거, 기본적으로 image 내부의 모든 layer를 함께 제거
  - (사용 방법) docker rmi \[image id\]
      - 다음과 같이 여러 image를 한 번에 제거할 수도 있음
      - docker rmi \[image id\] \[image id\] ...
  - 현재 container에서 사용되지 않는 image만 제거 가능, 중지된 container에서 사용 중인 image도 제거 불가
  - cf. images → 갖고 있는 모든 image 목록 확인
    - (사용 방법) docker images
  - cf. image prune → 사용되지 않는 모든 image들 제거
    - (사용 방법) docker image prune
- image inspect → image에 대한 정보 출력
  - (사용 방법) docker image inspect \[image id 혹은 image repository 이름\]
- cp → 실행 중인 container와 local host machine 간 파일 복사
  - (사용 방법) docker cp \[source 파일 혹은 디렉토리\] \[destination 경로\]
    - 디렉토리에 있는 모든 것을 복사하려면 \[디렉토리 경로\] 혹은 \[디렉토리 경로/.\]으로 입력
    - container가 대상인 경로 쪽에 container name을 명시 ex. local-redis:/app (cf. 마치 C:/Users 같은 느낌)
    - destination 경로가 존재하지 않으면 생성함
    - ex1. docker cp dummy/. local-redis:/app
    - ex2. docker cp local-redis:/app/test.txt test
  - 오류 발생 가능성 때문에 대체로 사용하지 않는 편이 좋겠지만
    - web server 구성 파일 변경, 로그 파일 복사 등 간단한 작업에 사용해볼 수 있음
