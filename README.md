# Docker, Kubernetes 예제

## 준비
### Docker 설치
- [docker docs 공식 문서](https://docs.docker.com/)
  - [Windows용 Docker Desktop 설치](https://docs.docker.com/desktop/install/windows-install/)
    - [Windows WSL 설치 방법](https://learn.microsoft.com/en-us/windows/wsl/install)
      - [Docker Desktop WSL 2 backend on Windows](https://docs.docker.com/desktop/wsl/)
    - [Windows Hyper-V 관련](https://docs.docker.com/desktop/troubleshoot/topics/#virtualization)
      - [Hyper-V 관련 설명](https://learn.microsoft.com/en-us/windows-server/virtualization/hyper-v/hyper-v-technology-overview)
    - [Windows에서 Docker 권한 문제 관련](https://docs.docker.com/desktop/windows/permission-requirements/)
- [WSL 2에서 Docker 원격 컨테이너 시작](https://learn.microsoft.com/ko-kr/windows/wsl/tutorials/wsl-containers)
- [WSL 2에 직접 Docker 설치하기\(네이버 블로그 참고\)](https://blog.naver.com/ilikebigmac/222007741507)
  - 굳이 이 블로그 글을 보기보다는 Docker 공식 문서 Install Docker Engine on Ubuntu 부분을 참고하면 될 듯

### VSCode 설정
- (확장) Docker, Prettier 등

### Docker 살펴보기
- [reference documentation](https://docs.docker.com/reference/)
  - [CLI reference](https://docs.docker.com/reference/cli/docker/)
  - [Develop with Docker Engine API](https://docs.docker.com/engine/api/)
- [Overview of Docker Desktop](https://docs.docker.com/desktop/)
  - Docker Desktop은 Docker Engine, Docker CLI client, Docker Scout, Docker Build, Docker Extensions, Docker Compose, Docker Content Trust, Kubernetes, Credential  Helper를 포함
  - Docker Engine은 애플리케이션을 빌드하고 컨테이너라이즈하는 컨테이너 기술
  - Docker Scout는 vulnerability에 대한 chain security 강화를 위한 것 [Docker Scout](https://docs.docker.com/scout/)
  - Docker Build는 image 만들기, 코드 패키징 등을 위한 것 [Overview of Docker Build](https://docs.docker.com/build/)
  - Docker Compose multi-container 애플리케이션을 정의하고 실행하기 위한 도구 [Docker Compose overview](https://docs.docker.com/compose/)
- [Docker Engine overview](https://docs.docker.com/engine/)
  - Docker Engine은 client-server 애플리케이션과 같이 동작함
    - dockerd가 daemon process인 server 역할
    - 프로그램들이 daemon과 소통할 수 있는 인터페이스인 APIs
    - docker는 CLI client 역할
      - CLI가 daemon과 상호작용하기 위해 스크립트 혹은 CLI 직접 명령을 통해 Docker APIs를 이용
  - Docker daemon 관련 참고
    - [Windows의 Docker 엔진](https://learn.microsoft.com/ko-kr/virtualization/windowscontainers/manage-docker/configure-docker-daemon)
    - [Start the daemon](https://docs.docker.com/config/daemon/start/)
    - Windows에서는 dockerd 명령어를 통해 Docker daemon을 실행할 수 없는 것으로 알고 있음
    - 하지만 C:\ProgramData\Docker\config\daemon.json 파일을 이용해 Docker daemon 구성을 변경할 수는 있음
  - [Install Docker Engine](https://docs.docker.com/engine/install/) Linex에서 Docker를 사용하고자 한다면 Docker Engine을 설치
    - [Install Docker Engine on Ubuntu](https://docs.docker.com/engine/install/ubuntu/)

## 핵심 정리
### image
- 핵심
  - 애플리케이션 코드와 이를 실행하는 데 필요한 도구, 설정 포함
  - container의 템플릿, 청사진
- 특성
  - layer based architecture
    - Dockerfile의 모든 명령이 image context의 각 layer를 나타냄
    - image 빌드 시 Docker는 모든 명령 결과을 cache, 다시 실행할 필요가 없는 것으로 판단된 명령은 cache된 결과를 사용
    - 변경이 있을 경우 모든 후속 layer에 대해서 캐시 결과를 사용하지 않음
  - read-only
    - 명령이 실행되고 image가 빌드되면 image의 code를 변경할 수 없음
    - 변경이 필요하면 새로운 image 빌드
- image 정보 검사(inspect)
  - docker image inspect \[image id 혹은 image repository 이름\]로 image의 정보 확인 가능
  - image의 full id, 생성 시간, container 구성 정보(노출 포트, 환경 변수, entry point, 사용 OS, layer들 등등)
- image tags
  - name:tag로 구성, name은 repository라고도 함 ex. redis:latest
    - name과 tag를 결합해 unique identifier로 기능함
    - name은 image의 일반적인 이름, 특정 image group을 정의
    - tag는 위 name으로 형성된 특정 image group에서 특정 image를 정의 → 특정 version처럼 사용
### container
- 핵심
  - 소프트웨어 실행 단위 - 애플리케이션과 실행 환경을 포함하는 작은 패키지
  - image의 구체적인 실행 인스턴스
  - container 실행 시 image layer 위에 새로운 container layer를 추가
    - container는 image 위에 추가된 얇은 명령 layer → 실행 중인 container의 size(용량)은 그리 크지 않음
    - 동일한 image를 기반으로 실행되는 여러 container는 image 내부 코드를 공유
- lifecycle
  - 참고 [Lifecycle of Docker Container](https://medium.com/@BeNitinAgarwal/lifecycle-of-docker-container-d2da9f85959)
- attached 모드, detached 모드
  - attached(연결) 모드
    - container를 foreground에서 실행 (cf. docker run으로 실행할 경우 attached 모드가 디폴트)
    - container의 출력 결과를 수신(attach to STDIN, STDOUT or STDERR)
  - detached(분리) 모드
    - container를 background에서 실행 (cf. docker start로 실행할 경우 detached 모드가 디폴트)
- interactive 모드
  - container와 container로 실행 중인 app이 상호작용할 수 있는 모드
  - STDIN을 open으로 유지, attached 모드가 아니어도 상관 없음
  - 주로 pseudo-TTY를 할당하여 터미널을 생성하는 옵션과 함께 실행
### Dockerfile
- [Dockerfile reference](https://docs.docker.com/compose/intro/history/)
- 자체 이미지를 빌드할 때 실행하려는 명령이 있는 파일
  - Dockerfile의 각 명령이 image context의 각 layer가 됨
- Dockerfile 작성
  - image 빌드 시 cache를 사용하도록 명령 순서 최적화 필요
  - \(1\) base image 지정
    - FROM [image 이름] → ex. FROM node
    - 보통 Docker 파일 첫 줄이 됨
    - 다른 base image 위에 커스텀 이미지를 구축 ex. OS layer , runtime 환경 같은 것들
    - 로컬 시스템에 있는 image 혹은 Docker Hub 등 registry에 있는 image 이름을 명시
  - \(2\) 작업 경로 지정
    - WORKDIR \[path\] → ex. WORKDIR /app
    - 모든 후속 명령도 해당 경로에서 실행
  - \(3\) 로컬 머신에 있는 파일 복사
    - COPY \[image의 외부 path\] \[path2\] → ex. COPY . ./
      - 첫번째 . → Dockerfile이 위치한 현재 경로를 기준으로 모든 디렉토리, 파일(하위 디렉토리, 파일 포함)을 복사, Dockerfile 자체는 포함하지 않음
      - 두번째 ./
        - 복사한 파일을 저장할 image 내부의 경로, image 및 container는 기본적으로 로컬 머신의 파일 시스템과 완전히 분리된 container 내부 파일 시스템을 가짐
        - ./ 으로 작성하면 WORKDIR로 지정된 경로에 복사, /app으로 명시적으로 작성할 수도 있음
    - image 빌드 시 cache 사용을 위해 일부 파일만 먼저 COPY 하도록 최적화 가능 → ex. COPY package.json /app
  - \(4\) 애플리케이션 빌드, 패키지 설정 등 작업을 위한 image 생성 시 필요 명령 작성
    - RUN \[명령어\]
      - ex. RUN npm install - cf. 시간이 오래 걸리는 작업은 Dockerfile 명령어 순서를 조정하여 cache를 사용할 수 있도록 최적화 필요
  - \(5\) 로컬 시스템과 통신할 포트 설정
    - EXPOSE [포트 번호 숫자] → ex. EXPOSE 80
    - CMD 명령보다 앞에 있어야 함
    - **EXPOSE 유의사항**
      - [Dockerfile reference- EXPOSE](https://docs.docker.com/reference/dockerfile/#expose)
      - EXPOSE: Describe which ports your application is listening on.
      - The EXPOSE instruction doesn't actually publish the port. ... Regardless of the EXPOSE settings, you can override them at runtime by using the -p flag.
      - EXPOSE는 문서화할 뿐임,  실제 포트 노출은 docker run -p 옵션을 통해 진행됨
  - \(6\) image를 바탕으로 container 시작 시 필요 명령 작성
    - CMD \[명령어를 위한 문자열 배열\] → ex. CMD \["node", "server.js"\]
    - CMD가 없는 경우 단지 base image가 실행됨
- Dockerfile 기반으로 커스텀 image 생성
  - docker build [Dockerfile이 있는 경로] → ex. docker build .
  - 빌드된 커스텀 image를 container로 실행하는 방법은 아래 Docker CLI 주요 명령어 중 run 부분 참고
- .dockerignore 파일
  - Dockerfile의 COPY 명령에서 복사해서는 안 되는 파일, 디렉토리 지정 가능
    - 마치 git에서 .gitignore 파일의 역할과 유사
- build-time에 사용할 ARGuments와 runtime에 사용할 ENVironment variables
  - ARG
    - Dockerfile에서는 ARG 명령어로 설정
    - docker build 시 --build-arg 옵션 사용
  - ENV
    - Dockerfile에서는 ENV 명령어로 설정
    - container 시작 시 -e 혹은 --env 옵션 사용, 파일에서 불러올 경우 --env-file 옵션 사용

#### ARG와 ENV
- 하드 코딩된 값 대신 ARG, ENV로 동적으로 부여된 값을 이용해 유연한 image, container를 만들 수 있음
- (ENV) runtime environment variable → image를 rebuild 하지 않고 환경 변수 값을 설정하여 보다 유연하게 container 구성 가능
  - [명령어 관련 공식 문서](https://docs.docker.com/reference/dockerfile/#env)
  - runtime에 application에서도 사용 가능한 값
  - 방법 1. Dockerfile에 명시
    - (정의 방법) ENV \[key\]=\[value\] 형태
      - 여러 key-value를 정의하려면 ENV 명령을 여러 번 수행해야 함
    - (사용 방법) 정의된 값을 사용할 때는 $\[key\] 형태로 불러와서 사용
  - 방법 2. container 시작 시 -e 혹은 --env 옵션 사용
    - (사용 방법) container 시작 시 옵션으로 --env \[key\]=\[value\] 부여
      - Dockerfile에 동일한 key의 environment variable이 있었을 경우, run할 때 부여한 value로 덮어 씀
      - --env 대신 -e로도 가능
      - 여러 개의 -v flag를 줄 수 있었듯이 여러 개의 -e flag로 여러 환경 변수 부여 가능
  - 방법 3. environment variable을 위한 별도 파일 작성, container 시작 시 --env-file 옵션 사용
    - 사용 방법
      - (관례적으로) .env 파일 사용
      - 파일에 \[key\]=\[value\] 형태로 여러 환경 변수를 지정
      - container 시작 시 --env-file \[.env 파일이 있는 경로\]/.env 옵션 추가
    - 환경 변수를 위한 별도 파일을 작성함으로써 보안 데이터 유출을 막을 수 있음
      - Dockerfile에 환경 변수를 포함시키면 docker history를 통해 이를 읽을 수 있음
      - 특히 자격 증명, 개인 키 등은 노출되지 않도록 유의
      - 별도 환경 변수 파일을 사용할 때도, 형상 관리 시 커밋되지 않도록 유의
- (ARG) build-time arguments → Dockerfile을 변경하지 않고 다른 argument를 부여하여 보다 유연하게 image build 가능
  - [명령어 관련 공식 문서](https://docs.docker.com/reference/dockerfile/#arg)
  - Docker image의 build-time에 사용되는 값이므로 Dockerfile의 CMD 명령어 및 source code에서는 ARG에 정의된 값을 사용할 수 없음에 유의
  - 방법 1. Dockerfile에 명시
    - (정의 방법) ARG \[key\]=\[value\] 형태
      - Dockerfile의 ENV와 다르게 ARG 정의 시에는 "="가 들어감의 유의
    - (사용 방법) 정의된 값을 Dockerfile 내에서 사용할 때는 $\[key\] 형태로 불러와서 사용
  - 방법 2. image build 시 --build-arg 옵션으로 명시
    - (사용 방법) image build 시 옵션으로 --build-arg \[key\]=\[value\] 부여
### image 공유
- container를 공유하지 않고 image를 공유, 공유된 image를 기반으로 container를 실행
- cf. Dockerfile 공유
  - Dockerfile과 함께 app의 source code를 제공, 공유된 파일을 이용해 image 빌드
  - Dockerfile의 위치를 중심으로 모든 파일과 디렉토리 구조까지 공유되어야 함
- 빌드된 image 공유
  - image를 다운(pull)받고 container를 실행하기만 하면 됨
  - image 자체를 공유할 때는 1. Docker Hub 혹은 2. Private Registry 이용
- registry: image 공유 위치
  - (1) Docker Hub: official Docker image registry
    - public, private, offical image들 존재
  - (2) private registry: Docker Hub 외에도 다양한 provider 존재
- 빌드된 image 공유 방법
  - (공유 시) docker push \[image 이름\]
  - (사용 시) docker pull \[image 이름\]
  - 공유를 위해선 먼저 registry에 image의 repository를 생성해두어야 함
    - registry의 repository와 일치하는 이름을 가진 local registry가 있어야 함
    - 즉 image의 이름이 registry repository와 같은 image가 있어야 함
  - private registry에서 image를 공유하고자 할 경우 \[provider url:image 이름\]과 같은 방식으로 host까지 명시해줘야 함
  - 참고 사항
    - push 할 때는 의존하고 있는 base image까지 함께 업로드 되진 않음
      - base image에 대한 연결을 설정하고, 추가 정보만 push
    - tag를 명시하지 않으면 latest tag를 자동으로 부여
### volume과 Docker external data storage
- volumes → directories on host machine which are mounted(or made available or mapped) into containers
  - container 외부의 특정 디렉토리에 연결된 Docker container 내부 디렉토리/파일
  - container가 volume을 mount하면 해당 volume의 data를 container에서 사용 가능
    - 사용 방식에 따라 container에서 volume에 data을 read, write 할 수 있고, 영속성이 필요한 data를 둘 수도 있음
- Docker의 external data storage
  - (external data storage를 이용하는 세 가지 방법) anonymous volume, named volume, bind mount
    - (세 방법의 공통점) container에서 정의된 경로가 host machine의 volume에 mounted(host machine 특정 경로에 mapped/mirrored) 
      - cf .anonymous volume이라고 해서 volume의 data가 host machine에 저장되지 않는 게 아님
  - (1) volume → managed by Docker
    - anonymous volume, named volume의 공통점
      - volume은 Docker에 의해서 관리됨
        - Docker에 의해 관리되므로 container 시작 시 volume이 존재하지 않으면 이를 생성함
      - host machine에 mapping된 정확한 경로를 찾기 어려우며, docker volume 명령을 통해서만 접근 가능, 직접 access 불가
    - (1-1) anonymous volume
      - (사용 방법) docker run -v /app/data ... 혹은 Dockerfile에 VOLUME 명령어 추가
      - 하나의 특정 container와만 연결될 것으로 예상하고 생성하는 volume으로 생각하면 될 것
        - container 시작 시 --rm 옵션을 준 경우, container 중지하면 container와 volume 함께 제거
        - **container 간 data 공유 불가, 같은 image를 사용하더라도 volume 재사용 불가**
        - **container에 이미 존재하는 특정 data를 수정할 수 없도록 하는 데에 유용함**
    - (1-2) named volume
      - (사용 방법) docker run -v volume-name:/app/data ...
      - 여러 container(특히 중지되고 다시 시작되는 container들)와 연결될 것을 염두에 두고 생성되는 volume
        - container 시작 시 --rm 옵션을 준 경우, container 제거 후에도 volume 유지
        - **volume 재사용 가능 → 영속성이 필요하지만, 직접 수정할 필요는 없는 data인 경우 사용**
        - **여러 container 간 data 공유 가능**
  - (2) bind mount → managed by user
    - (사용 방법) docker run -v /absolute/path/in/host/machine:/app/code ...
    - 명시한 container 내부 경로가 host machine에 mapping된 정확한 경로를 명시
      - container 제거 후에도 유지 → **영속성이 필요한 data**
        - Docker 명령어로는 bind mount의 data 삭제 불가, host의 file system에서 data를 직접 삭제 해야 함
      - bind mount에 있는 data를 수정 가능 → **container 내부 mapping된 경로에 있는 data\(source code까지도\) 수정 가능\(live data\)**
      - **여러 container 간 data 공유 가능**
    - cf. Docker Desktop을 사용한다면 Preferences → Resources → FILE SHARING에서 mount 가능한 host machine 경로 설정이 필요할 수 있음
      - 경로를 작성할 때 Linux에서는 -v $(pwd):/app, Windows에서는 -v "%cd%":/app과 같은 방식으로 바로 가기를 사용할 수 있음
  - 자세한 사용 예시는 아래 "Docker의 데이터 관리 및 volume 작업 → Docker external data storage를 이용한 permanent app data 작업"을 참고
  - 유의 사항
    - Docker container가 시작될 때 bind mount하면 Docker가 host machine의 local 경로를 덮어쓰지는 않지만,
      - container 내부의 경로가 host machine의 bind mount 경로 내용으로 덮어씌워짐에 유의
    - 이 문제를 해결하기 위해 mapping하기로 한 container 내부 경로 중 외부 내용으로 덮어쓰면 안 되는 부분이 있음을 알려줘야 함 ex. anonymous volume 활용
    - Docker는 volume 설정 간 충돌하는 부분이 있는 경우, 내부 경로가 더 구체적인 volume 설정을 우선 적용함
  - 참고 자료
    - [Understanding Docker Volumes: Anonymous Volumes, Named Volumes, and Bind Mounts](https://medium.com/@kavindumadushanka972/understanding-docker-volumes-anonymous-volumes-named-volumes-and-bind-mounts-bdae3af94330)
    - [Docker 컨테이너에 데이터 저장 (볼륨/바인드 마운트)](https://www.daleseo.com/docker-volumes-bind-mounts/)

## Docker CLI 주요 명령어 및 그 옵션
- --help
  - (모든 Docker CLI 명령어 확인) docker --help
    - cf. 예전에 사용했으나, 현재는 더 나은 명령어가 나왔기에 거의 사용할 일이 없는 명렁어도 있음
  - (특정 명령어의 옵션 확인) docker \[명령어\] --help → 해당 명령어에 대한 모든 옵션 확인
- push → image 업로드
  - (사용 방법) docker push \[image 이름\]
    - (private registry를 사용할 경우) docker push \[provider url:image 이름\]
- push → image 다운로드
  - (사용 방법) docker pull \[image 이름\]
    - (private registry를 사용할 경우) docker pull \[provider url:image 이름\]
- build → Dockerfile을 기반으로 image 빌드
  - (사용 방법) docker build .
  - \(-t flag 혹은 --tag \[list\]\) 빌드할 image에 name:tag 형식으로 image tag 부여
    - ex. docker build -t goals:1 .
    - cf. 만약 이미 존재하는 image의 이름을 변경하고자 한다면 tag 명령어를 사용
  - \(--build-arg \[key\]=\[value\]\) 빌드 시 ARG 값 부여 혹은 재정의
- tag → 이미 존재하는 image의 image tag(image 이름, repository)를 변경
  - (사용 방법) docker tag \[image의 현재 이름\] \[변경하고자 하는 이름\]
  - cf. 이전 image는 제거되지 않고, 변경된 이름을 가진 복제본 생성
- login → registry에 로그인
  - (사용 방법) docker login 입력 후 프롬프트에 따라 Username, Password 입력
    - (옵션을 이용해 Username, Password 입력) docker login -u \[Username\] -p \[Password\]
    - (다른 registry에 로그인할 경우) docker login \[registry url\]
  - cf. docker logout으로 registry에서 로그아웃 가능
- run
  - (사용 방법) docker run \[옵션\] \[image 이름\] \[실행할 명령어\] \[arg...\]→ image를 기반으로 새 컨테이너를 생성
    - run으로 다른 옵션 없이 container을 생성 및 시작할 경우 attached - 터미널에서 blocked(foreground 실행)
    - 이 상태에서 ctrl + c를 입력할 경우 status가 Exited가 됨
    - cf. local에 image가 없는 경우 registry에서 자동으로 pull → image가 있다면 image를 업데이트하진 않는다는 의미이기도 함
  - 명령어 오버라이드
    - \[실행할 명령어\] 부분에 명령어를 명시하면, 기본 동작 대신 명시한 명령어 실행 가능
  - 옵션들
    - \(-p flag 혹은 --publish \[list\]\) 로컬 머신의 어떤 포트가 container의 특정 포트에 접근하는데 사용되는지 명시 
      - -p \[app에 접근하려는 로컬 포트\]:[내부 container 노출 포트] → ex. -p 3000:80
    - \(-d flag\) detached 모드로 실행
    - \(-i flag 혹은 --interactive\) open STDIN - interactive 모드로 실행
    - \(-t flag 혹은 --tty\) pseudo-TTY 할당
    - \(--rm flag\) container를 중지할 때 제거되도록 함
    - \(--name flag \[string\]\) container에 이름을 부여
    - \(-v flag\) bind mount, volume 사용 등에 이용 → 자세한 설명은 아래 storage 부분 참고
    - \(-e flag 혹은 --env \[key\]=\[value\]\) container runtime 환경에서 사용할 환경 변수 부여
    - \(--env-file \[.env 파일이 있는 경로\]/.env\) container runtime 환경에서 사용할 환경 변수를 .env 파일에서 읽어서 사용
    - \(--network \[network 이름\]\) container를 container network와 연결
      - cf. -v와 달리 해당 이름을 가진 network가 존재하지 않으면 network를 생성하지는 않음
- start
  - (사용 방법) docker start \[container name 혹은 containter id\] → status가 Exited인 container를 다시 시작
    - start로 다른 옵션 없이 재시작할 경우 detached - 터미널에서 blocking하지 않음(background 실행)
  - \(-a flag\) attached 모드로 실행 → STDOUT/STDERR와 연결하는 것
    - 이 상태에서 ctrl + c를 입력할 경우 status가 Exited가 되지 않고 Up으로 계속 실행
  - \(-i flag 혹은 --interactive\) open STDIN
    - docker start d-ai .. 로 container에 attached되며 interactive 작업 가능해짐
- attach
  - (사용 방법) docker attach \[container name 혹은 containter id\] → detached 모드로 시작된 container에 attach
    - 이 상태에서 ctrl + c를 입력할 경우 status가 Exited가 됨
- logs
  - (사용 방법) docker logs \[container name 혹은 containter id\] → 해당 container의 로그 확인
  - \(-f flag 혹은 --follow\) Follow log output - 로그 출력 수신 대기, 앞으로 출력되는 로그도 확인하도록 연결
- rm → containter를 제거
  - (사용 방법) docker rm \[container name 혹은 containter id\]
    - 다음과 같이 여러 container를 한 번에 제거할 수도 있음
    - docker rm \[container name 혹은 containter id\] \[container name 혹은 containter id\] ...
    - 실행 중인 container는 기본 rm으로 제거 불가능, stop 후 제거 가능
  - cf. container prune → 중지된 모든 container를 제거
    - (사용 방법) docker container prune
    - cf. docker prune으로는 실행할 수 없음, management command인 container를 꼭 붙여야 함
- rmi → image를 제거, 기본적으로 image 내부의 모든 layer를 함께 제거
  - (사용 방법) docker rmi \[image id\]
      - 다음과 같이 여러 image를 한 번에 제거할 수도 있음
      - docker rmi \[image id\] \[image id\] ...
  - 현재 container에서 사용되지 않는 image만 제거 가능, 중지된 container에서 사용 중인 image도 제거 불가
  - cf. images → 갖고 있는 모든 image 목록 확인
    - (사용 방법) docker images
  - cf. image prune → 사용되지 않는 모든 image들 제거
    - (사용 방법) docker image prune
- image inspect → image에 대한 정보 출력
  - (사용 방법) docker image inspect \[image id 혹은 image repository 이름\]
- container inspect → container에 대한 정보 출력
  - (사용 방법) docker container inspect \[container 이름\]
    - "NetworkSettings"의 "IPAddress" 등 정보 확인 가능
- cp → 실행 중인 container와 local host machine 간 파일 복사
  - (사용 방법) docker cp \[source 파일 혹은 디렉토리\] \[destination 경로\]
    - 디렉토리에 있는 모든 것을 복사하려면 \[디렉토리 경로\] 혹은 \[디렉토리 경로/.\]으로 입력
    - container가 대상인 경로 쪽에 container name을 명시 ex. local-redis:/app (cf. 마치 C:/Users 같은 느낌)
    - destination 경로가 존재하지 않으면 생성함
    - ex1. docker cp dummy/. local-redis:/app
    - ex2. docker cp local-redis:/app/test.txt test
  - 오류 발생 가능성 때문에 대체로 사용하지 않는 편이 좋겠지만
    - web server 구성 파일 변경, 로그 파일 복사 등 간단한 작업에 사용해볼 수 있음
- exec → container에 대해 Dockerfile에 정의된 명령어 외의 다른 명령 실행 가능
  - (사용 방법) docker exec \[옵션\] \[container 이름\] \[실행할 명령어\] \[arg...\]
    - docker container exec ... 으로도 가능
  - 사용 예시
    - docker exec -it node-container /bin/bash
      - cf. container를 시작할 때 -it 옵션을 주었더라도, 명령어 실행 시 다시 -it 옵션 필요
- (management command) volume
  - volume ls → 현재 존재하는 volume 목록\(list\) 확인
    - (사용 방법) docker volume ls
    - cf. bind mount는 Docker에 의해 관리되는 volume이 아니므로 목록에 나오지 않음
  - volume create → volume 생성
    - (사용 방법) docker volume create \[volume 이름\]
    - 하지만 수동으로 volume을 생성해두어야할 경우는 많지 않을 것
  - volume prune → 사용되지 않는 모든 local volume 제거
  - volume rm → 명시한 volume 제거
    - (사용 방법) docker volume rm \[volume 이름\] \[volume 이름\] ...
  - volume inspect → volume에 대한 자세한 정보 출력
    - (사용 방법) docker volume inspect \[volume 이름\] \[volume 이름\] ...
      - 옵션으로 -f \[template 이름\]을 줄 경우 특정 format으로 출력 가능 - [참고](https://docs.docker.com/go/formatting/)
    - CreatedAt, Driver, Name, Mountpoint, Options\(읽기 전용 여부 등 옵션\) 등 표시
      - (mountpoint) 실제로 data가 저장되는 host machine 상 경로
        - Docker가 생성한 volume이 있는 위치, 하지만 host machine 파일 시스템 상에서 실제로 확인할 수는 없음    
- (management command) network
  - network create → container network 생성
    - (사용 방법) docker network create \[network 이름\]
      - (--driver 옵션) 네트워트 생성 시 사용할 Docker network driver 선택 → 생략할 경우 bridge 드라이버 사용
  - network ls → container network 목록 확인
    - (사용 방법) docker network ls
    - cf. bridge, host, none 등 몇 가지 기본 내장 network도 있으므로, 굳이 강제로 제거하지 말 것(prune 명령으로 제거 안 되는 network들)

## Docker의 data 관리 및 volume 작업
- [Docker Engine의 storage 관련 공식 문서 참고 자료](https://docs.docker.com/storage/)
### Docker에서 다루는 data의 종류와 해결 과제
- Docker에서 다루는 data의 종류
  - (1) application(source code + environment)
    - image 빌드 시 image에 복사되는 data
    - image가 빌드되면 변경 불가(read-only)
    - image에 저장된 data
  - (2) temporary app data
    - app이 실행되는 동안 container에서 생성되는 data, 읽고 쓰기 가능
    - 없어져도 괜찮은 data → memory, 임시 파일 등으로 저장
    - container에 저장된 data → image 위에 있는 container를 구성하는 layer
  - (3) permanent app data
    - app이 실행되는 동안 container에서 생성되는 data, 읽고 쓰기 가능
    - 지속되어야 하는 data → DB, 파일 형태로 저장
      - container가 중지, 재시작, 제거 되더라도 남아야 하는 data
    - container에 저장되지만, volume의 도움을 받아야 함
- 해결 과제: Docker container의 data 문제
  - 기본적으로 local(host machine) file system과 container 혹은 image는 연결되어 있지 않음
  - Dockerfile로 image를 빌드할 시점의 파일 및 디렉토리가 일종의 snapshot이 된다고 생각할 수 있음
  - container 내부 file system과 host machine의 local file system은 별개
    - container 내부 file system은container을 stop해도 사라지지는 않음
    - 당연히 image 기반으로 구축된 application source code 등도 사라지지 않음
    - 하지만 container를 제거하면 container의 모든 data 제거
  - container layer는 read, write 가능이지만, image layers는 read-only
    - container layer의 data 변경 사항은 image layer에 반영되지 않음
    - 단지 container layer의 read-write 가능 layer에 저장될 뿐
### Docker external data storage를 이용한 permanent app data 작업
- 영속성이 필요한 data, bind mount로 덮어씌워지면 안 되는 data를 고려하여 anonymous volume, named volume, bind mount를 적절히 함께 사용
  - 유의 사항
    - Docker container가 시작될 때 bind mount하면 Docker가 host machine의 local 경로를 덮어쓰지는 않지만,
    - container 내부의 경로가 host machine의 bind mount 경로 내용으로 덮어씌워짐에 유의
  - anonymous volume를 사용하는 예시 → 영속성이 없음
    - (ex. Dockerfile 명령어 예시) VOLUME [ "/app/feedback" ]
    - (ex. Docker CLI 명령어 예시) container 시작 시 -v /app/feedback 옵션 추가
  - named volume을 사용하는 예시 → data를 수정할 수 없음
    - (ex. Docker CLI 명령어 예시) docker run -d -p 3000:80 --rm --name feedback-app -v feedback:/app/feedback feedback-node:volumes
  - bind mount를 사용하는 예시 → bind mount mapping된 host machine 경로의 data가 덮어씌워져서 container의 app이 실행되지 않을 수 있음
    - (ex. Docker CLI 명령어 예시) docker run -d -p 3000:80 --rm --name feedback-app -v "C:\docker-kubernetes-example\docker-volume-example":/app feedback-node:volumes
  - 위 세 external data storage를 함께 사용하는 예시
    - (ex. Docker CLI 명령어 예시) docker run -d -p 3000:80 --rm --name feedback-app -v "/mnt/c/docker-kubernetes-example/docker-volume-example":/app -v feedback:/app/feedback -v /app/node_modules feedback-node:volumes
      - cf. host machine의 절대 경로 전체를 큰 따옴표로 묶어도 됨, 특히 공백, 특수 문자가 있는 경우 필요할 것 ex.  "~/volume-ex"
      - mapping하기로 한 container 내부 경로 중 host machine의 bind mount 경로의 내용으로 덮어쓰면 안 되는 부분을 제외하기 위해 anonymous volume을 활용한 것
        - Docker는 volume 설정 간 충돌하는 부분이 있는 경우, 내부 경로가 더 구체적인 volume 설정을 우선 적용
        - 즉 위 예시의 경우 /app/node_modules에 mapping되는 곳은 bind mount를 위해 지정된 local 경로가 아닌 anonymous volume  
          → /app/node_modules가 host의 bind mount 경로의 내용물로 덮어쓰여지지 않게 하는 것
- Docker를 활용하면서 편리한 개발 환경 구축하기
  - bind mount까지 적용했다면 image를 다시 build 하지 않아도 source code 변경사항을 app에서 확인 가능
    - app의 source code를 host machine의 bind mount 경로에 두고, 이 source code를 변경하면 app에서 변경 사항 확인 가능
    - node.js 서버의 경우 nodemon 라이브러리 사용하면 편리 → souce code 변경사항이 바로 app에 반영
      - package.json에 devDependencies로 nodemon 추가 및 "npm start" script 설정
      - Docker file에서 CMD 변경 후 image 다시 빌드하여 라이브러리 추가 내용 반영
      - cf. Windows OS에서 WSL2를 host machine으로 사용하면서 Windows 파일 시스템에 있는 파일을 변경 중이라면 파일 변경 전파의 문제로 nodemon이 동작하지 않을 수 있음
        - (참고) [Access Linux filesystems in Windows and WSL 2](https://devblogs.microsoft.com/commandline/access-linux-filesystems-in-windows-and-wsl-2/), [Docker Desktop: WSL 2 Best practices](https://www.docker.com/blog/docker-desktop-wsl-2-best-practices/)
        - 단순하지만 지저분한 방법으로는 nodemon을 -L 옵션으로 시작할 수 있음 → [nodemon 공식 문서 참고 ](https://github.com/remy/nodemon?tab=readme-ov-file#application-isnt-restarting)
    - nodemon 같은 라이브러리를 사용하지 않으면, image 빌드는 하지 않더라도 source code 변경사항 적용을 위해 container 재시작 필요
  - cf. 이렇게 bind mount를 이용하여 source code 변경 사항을 바로 반영하는 방식은 개발 환경에서 사용하는 것
    - 운영 환경에서는 코드의 snapshot을 이용하지, 실시간으로 변경되는 source code를 이용하지 않음 → Dockerfile에서 COPY 명령어는 여전히 필요함
- 읽기 전용 external data storage
  - container 쪽에서는 external data storage의 data를 읽기만 가능하게 하려면 :ro를 추가
    - ex. -v "/mnt/c/docker-kubernetes-example/docker-volume-example":/app:ro
      - (전체 명령어) docker run --rm -d -p 3000:80 --name feedback-app -v "/mnt/c/docker-kubernetes-example/docker-volume-example":/app:ro -v feedback:/app/feedback -v /app/node_modules feedback-node:volumes
    - 그 하위 경로까지 수정할 수 없게 함, 하지만 하위 경로이더라도 더 구체적으로 명시된 write 가능 volume이 있다면 수정 가능

## Docker container의 통신
- [Docker Engine의 networking 관련 공식 문서 참고 자료](https://docs.docker.com/network/)
- conatiner에서 가능한 통신의 종류
  - 1. container와 web 간 통신
  - 2. container와 host machine 간 통신
  - 3. container와 다른 container 간 통신
### container와 web 간 통신
- container는 기본적으로 world wide web에 요청 전송 및 응답 수신/요청 수신 및 응답 전송 가능
  - 이를 위한 특별한 설정, 코드 변경 불필요
### container와 host machine 간 통신
- 특수 도메인 host.docker.internal 이용 → ex. mongodb://host.docker.internal:27017/swfavorites
  - container가 host machine과 통신하려면 localhost 도메인으로는 불가능
  - 특수 도메인이 Docker container 내부에서 알 수 있는 host machine의 IP 주소로 변환됨(변환 자체는 Docker에서 알아서 처리)
### container와 다른 container 간 통신
- (1) container inspect를 통해 IP 주소 확인 후 IP 주소 직접 명시
  - 기본적으로는 container 간 통신을 위해 연결하고자 하는 container의 IP 주소를 알아야 함
  - docker container inpspect \[container 이름\] 명령을 통해 IP 주소 확인 ← "NetworkSettings"의 "IPAddress" 부분의 값 확인
  - 확인한 연결 대상 IP 주소를 명시하여 연결 수립 → 연결 대상의 IP 주소가 변경되면 image도 rebuild 해야하는 단점
- (2) container networks를 이용한 통신
  - container 시작 시 --network 옵션을 이용해 동일한 containter network 안에 있도록 함
  - 연결 시의 domain 이름은 container 이름을 사용
    - container 이름이 Docker에 의한 자동 변환 과정을 거쳐 해당 container의 IP 주소로 변환됨
  - cf. 동일 container network 안에 있는 경우, 통신 시 port에 대한 pulish 불필요
    - -p 옵션은 host machine으로부터의 연결 혹은 container network 외부로부터의 연결이 필요할 때 사용
### 참고 사항
- 위에서 container networks라고 표현한 것은 공식 문서에서는 user-defined bridge networks라 표현
  - [공식 문서 참고](https://docs.docker.com/network/network-tutorial-standalone/#use-user-defined-bridge-networks)
  - 공식 문서에서는 default bridge network 사용을 피하고, user-defined bridge networks를 사용할 것을 권한
- container에서 요청을 전송할 때만 자동 IP 변환(특수 도메인, container 이름 등을 IP로 변환해주는 것)이 발생함에 유의
  - 요청이 client의 브라우저에서 생성된 경우, 자동으로 IP를 변환해 주지 않음
- Docker network driver - [공식 문서 참고](https://docs.docker.com/network/drivers/)
  - (bridge) 디폴트, 같은 host의 다른 container와 통신 가능
  - (host) container와 host 시스템 간 격리 제거 
  - (overlay) 서로 다른 host machine에서 실행되는 Docker daemon 연결(swarm 모드에서 작동)
  - (ipvlan) contiainer의 IPv4, IPv6 주소에 대해 통제하여 통신
  - (macvlan) container에 커스텀 MAC 주소 설정하여 통신에 이용
  - (none) 모든 네트워킹 비활성화
  - (network plugins) container networking에 third-party network plugin 사용

## Docker Compose를 이용한 multi-container 설정 자동화
- [Docker Compose Manual](https://docs.docker.com/compose/)
- [Docker Compose file reference](https://docs.docker.com/compose/compose-file/)
- Linux에서는 별도로 Docker Compose 설치 필요 - [참고](https://docs.docker.com/compose/install/)
### Docker Compose는?
- orchestration(자동화된 설정) commands set
  - 여러 build, run, ... 등 명령을 configuration file을 이용해 하나의 명령으로 실행할 수 있음
    - cf. 부분적으로만 대체하여 편리하게 이용하는 것이지 완전히 대체하는 것은 아님, docker-compose 명령으로 생성된 image, container, volume 등에 대해 기존 docker 명령 그대로 이용 가능
- 오해하지 말 것
  - Docker Compose가 custom image를 위한 Dockerfile을 대체하는 게 아님 → Dockerfile과 함께 작동
  - Docker Compose가 image나 container을 대체하는 게 아님 → image, container를 더 쉽게 작업할 수 있도록 도와줄 뿐
  - Docker Compose는 서로 다른 host machine에서 동작하는 multiple container를 관리하기에 좋은 도구는 아님 → 동일한 host machine 내에서 multiple container 관리를 용이하게 함
- Docker Compose 파일
  - 터미널에서 docker 명령어를 입력하는 대신 Docker Compose 파일을 작성할 것
  - 이 Docker Compose 파일에 multi conatiner app을 구성하는 핵심 구성 요소를 정의
    - 가장 중요한 요소는 service → container를 의미함
      - 각 service의 published ports, environment variables, volumes, networks 등을 정의
### Docker Compose 파일 작성하기
#### docker-compose.yml 준비
- 프로젝트 루트에 docker-compose.yml 혹은 yaml 파일 생성
  - yaml 파일은 들여쓰기를 사용하여 구성 옵션 간 종속성을 표현하는 특정한 텍스트 포맷
  - 이 파일에 \(multi\) container 환경, 프로젝트 설정을 기재할 것
#### docker-compose.yml 파일의 구성
- 참고 사항
  - 각 key는 정해져있는 단어들이므로 오타 있으면 동작하지 않음 → VSCode Docker extension의 자동 완성 적극 사용
  - 각 value의 문자열은 "쌍따옴표로도 '홑따옴표로도 표현 가능, 따옴표를 생략할 수도 있음
- version top-level element → obsolete, 현재는 docker-compose.yml 작성 시 version을 명시하지 않음
  - Docker Compose의 version을 지정 → 사용할 수 있는 Docker Compose 기능과 관련
  - [Docker Compose의 과거 관련 참고](https://docs.docker.com/compose/intro/history/)
  - **현재는 Compose Specification 방식으로 동작** → version을 명시하지 않고, 구현 시 알아서 최신 schema를 사용
- name top-level element
  - project의 이름을 나타내는 요소
    - docker-compose.yml에 명시하지 않고, 다른 방식으로 project name을 명시할 수도 있음 → [참고](https://docs.docker.com/compose/project-name/)
    - 명시하지 않을 경우, docker-compose.yml이 있는 디렉토리의 이름을 자동으로 사용
  - 환경 변수 COMPOSE_PROJECT_NAME으로 사용됨
- services top-level element
  - 중첩된 key-value 형태를 가짐
    - [services에서 사용할 수 있는 key들에 대한 reference](https://docs.docker.com/compose/compose-file/05-services/)
  - services의 하위 요소는 각 container가 됨 → 하위 요소의 key가 각 service의 label이 됨
    - 이 service의 label은 container name과 일치하지는 않음
    - 이 label은 container name의 일부분으로 선택됨
    - container name은 \[project의 name\] _ \[service의 name\] _ \[증가하는 숫자\]로 구성
      - container name을 굳이 지정하고 싶다면, 각 service의 하위 요소로 container_name key를 지정 가능
  - 각 label 하위로 각 container의 구성을 정의
    - 자세한 방법은 아래 "docker-compose.yml 파일 중 container 구성 부분" 참고
- network top-level element
- volumes top-level element
  - 각 service에서 사용할 named volume을 나열
    - named volume의 name을 key에 명시 →, value에는 아무 값도 주지 않음
    - 각 service에서 명시된 named volume이 있는데, volumes top-level element에 해당 named volume이 없다면 invalid compose project 에러
  - anonymous volume과 bind mount는 이 element에 명시하지 않음
#### docker-compose.yml 파일 중 services의 하위 요소 구성
- 기본적으로 container를 run(create) 할 때 부여하는 옵션들을 이 부분에 명시한다고 생각하면 될 것
  - cf. (-d 옵션) docker-compose up -d로 가능, (--rm 옵션) docker-compose up -d로 시작했다면 docker-compose down 시 알아서 container 제거
- image key → container의 image
  - local image, registry에 있는 image, custom image 모두 가능
- build key → image 대신 container를 시작할 때 사용할 image의 build에 필요한 정보를 제공
  - cf. docker compose up 할 때마다 매번 image를 다시 build 하지는 않고, 변경 사항이 있는 경우에만 다시 build
    - Docker Compose에서 알아서 감지하여 처리
  - (방법 1) Dockerfile이 있는 디렉토리를 명시 ex. build: ./backend
  - (방법 2) 중첩 key가 있는 형태, build 하위 요소로 다음을 key-value 형태로 명시
    - context → Dockerfile이 있는 디렉토리 경로 ex. context: ./backend
    - dockerfile → Dockerfile의 이름 ex. Dockerfile-backend → dockerfile의 이름이 Dockerfile인 경우 이 방법을 사용할 필요는 없을 것
    - args → Dockerfile에서 ARG를 사용하는 경우 여기에 key-value 형태로 명시 가능
- volumes key → container의 volume 설정
  - "-"(hyphen)을 이용한 중첩 형태 list 표현
  - \- 뒤에 Docker 명령어에 붙인 것과 같은 문자열을 입력 ex. - data:/data/db:ro
  - cf. bind mount 시 CLI 명령과 다르게, docker-compose.yml 파일 기준으로 상대 경로 사용 가능
- environment key → container의 환경 변수 설정
  - (방법 1) key-value 형태
  - (방법 2) "-"과 "="을 이용한 list 표현
- env_file key → container의 환경 변수를 담고 있는 파일 지정
  - "-"과 "="을 이용한 list 표현, docker-compose.yml 파일 기준 환경 변수 파일의 상대 경로 입력
- networks key → container가 속해야 하는 모든 네트워크를 특정
  - "-"과 "="을 이용한 list 표현
  - 그런데 Docker Compose를 이용할 경우
    - 하나의 docker-compose.yml에서 정의된 service들은 동일한 네트워크의 일부가 되므로
    - 각 label의 하위 요소로 networks key를 명시할 경우가 많지 않을 것
    - cf. 아무런 networks를 명시하지 않았다면 \[project 이름\]_default 라는 이름을 가진 네트워크를 생성하여 사용
- ports key → container가 publish할 port들
  - "-"과 "="을 이용한 list 표현
  - create 시 옵션과 마찬가지로 \[host port\]:\[container port\] 형태
- depends_on key → 해당 service가 의존하는 service를 명시(해당 service보다 먼저 시작되어야 하는 service)
  - "-"과 "="을 이용한 list 표현으로 service의 이름 명시
- stdin_open key → 해당 service에 open input connection이 필요함을 명시, docker create의 -i flag
  - true 혹은 false
- tty key → 표준 입력을 위한 터미널 연결, docker create의 -t flag
  - true 혹은 false
- container_name key → container 이름을 정확하게 지정하고 싶은 경우
### Docker Compose로 services 시작하기
- 터미널에서 docker-compose.yml이 있는 디렉토리로 이동
- docker-compose up
  - docker compose up 입력 시 docker-compose.yml 파일 기반으로 image build 및 container 시작
  - 필요한 image가 있다면 자동으로 다운로드함
  - detached 모드로 시작하려면 -d 옵션 추가
- docker-compose down 
  - docker-compose down 입력 시 service 중지 및 container 제거
  - docker-compose up 할 때 -d 옵션이 있었다면,
    - docker-compose down할 때 container까지 알아서 제거 → container 시작 시 -d --rm 옵션이 있었던 것과 같은 효과
  - volume은 자동으로 제거되지 않음
    - 사용된 volume까지 제거하려면 -v 옵션 추가 ex. docker-compose down -v
- cf. container 이름 관련
  - docker compose up 후 docker ps로 현재 container를 확인해보면 container 이름과 service 이름 불일치
  - 그럼에도 Docker network 등에서는 service에 부여한 이름을 그대로 사용하면 됨
  - cf. 각 service의 container_name key로 container name을 정확히 지정할 수 있으나 굳이 필요하지 않음
- cf. docker-compose build
  - build 해야할 Dockerfile의 일부를 변경했으나, docker compose up 명령 시 다시 build 하지 않고, 예전 image를 그대로 사용하는 경우
    - docker compose build 명령으로 다시 build 하도록 함
    - docker compose up --build로 --build 옵션을 줘서 image rebuild를 강제하며 container 시작까지도 가능
  - docker-compose.yml 설정을 일부 변경 했으나, 다시 build 하지 않는 경우
    - docker compose build --no-cache로 기존 cache를 사용하지 않도록 시도

## (application container가 아닌) utility 성격 작업을 위한 container 사용 사례
- host machine에 node.js를 설치하지 않고 node container 및 bind mount를 이용해 host machine에서 node를 활용한 작업 가능
### Dockerfile을 사용하는 경우
- Dockerfile에 다음만 작성된 상태에서 image를 build 하고 실행
  - FROM node:20-alpine
  - WORKDIR /app
- cf. pwd 결과값을 이용한 간편한 실행
  - (Windows) docker run -it --rm -v ${pwd}:/app node-util npm init
  - (Linux) $( ) 혹은 \` \`을 이용
    - docker run -it --rm -v $(pwd):/app node-util npm init
    - docker run -it --rm -v \`pwd\`:/app node-util npm init
    - [참고 - 명령어 실행결과를 변수에 할당](https://wikidocs.net/54525)
- cf. Dockerfile ENTRYPOINT 활용
  - ENTRYPOINT는 CMD와 유사하지만, docker run 실행 시 입력된 명령어가 ENTRYPOINT를 오버라이드 하지 않고, append 하는 방식으로 동작
- cf. \(npm 명령어 관련\) npm install \[패키지 이름\] --save
  - 입력한 패키지 모듈을 설치하면서 package.json의 dependency 항목에도 해당 종속성을 기록함
  - npm 5부터는 --save가 기본 옵션
### Docker Compose를 사용하는 경우
- docker-compose.yml 파일 작성
  - ./docker-utility-container-example/docker-compose.yml 파일 참고
- docker compose run을 이용한 실행
  - docker compose run \[service 이름\] \[실행할 명령어\]
    - docker-compose.yml 파일에 명시된 service를 개별로 명령어까지 전달하며 실행 가능
  - ex. docker compose run --rm node-service init
    - container stop 시 제거되도록 하려면 --rm 옵션 추가(up처럼 -d 옵션이 아님)
    - 만약 service 이름을 npm으로 정했다면 docker compose run --rm node npm init과 같은 형태가 됨
      - Dockerfile의 ENTRYPOINT [ "npm" ]과 합쳐져서 자연스러운 모양새가 됨
- cf. **docker compose up 으로 실행할 수 없음**
  - ENTRYPOINT로 지정된 npm만 실행하고 종료
  - docker compose up init 이런 방식으로도 불가능
    - docker compose up --help 해보면 docker compose up 뒤의 자리는 개별로 실행할 service 이름을 명시하는 자리
    - up을 이용한 방식은 계속 실행되어야 하는 application container에 적합, utility 성격 container에는 부적합
### cf. Docker 활용 생성된 파일 관련, 권한 문제 발생할 경우 참고
- [Avoiding Permission Issues With Docker-Created Files](https://vsupalov.com/docker-shared-permissions/)
