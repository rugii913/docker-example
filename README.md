# Docker, Kubernetes 예제

## 준비
### Docker 설치
- [docker docs 공식 문서](https://docs.docker.com/)
  - [Windows용 Docker Desktop 설치](https://docs.docker.com/desktop/install/windows-install/)
    - [Windows WSL 설치 방법](https://learn.microsoft.com/en-us/windows/wsl/install)
      - [Docker Desktop WSL 2 backend on Windows](https://docs.docker.com/desktop/wsl/)
    - [Windows Hyper-V 관련](https://docs.docker.com/desktop/troubleshoot/topics/#virtualization)
      - [Hyper-V 관련 설명](https://learn.microsoft.com/en-us/windows-server/virtualization/hyper-v/hyper-v-technology-overview)
    - [Windows에서 Docker 권한 문제 관련](https://docs.docker.com/desktop/windows/permission-requirements/)
- [WSL 2에서 Docker 원격 컨테이너 시작](https://learn.microsoft.com/ko-kr/windows/wsl/tutorials/wsl-containers)
- [WSL 2에 직접 Docker 설치하기\(네이버 블로그 참고\)](https://blog.naver.com/ilikebigmac/222007741507)
  - 굳이 이 블로그 글을 보기보다는 Docker 공식 문서 Install Docker Engine on Ubuntu 부분을 참고하면 될 듯

### VSCode 설정
- (확장) Docker, Prettier 등

### Docker 살펴보기
- [reference documentation](https://docs.docker.com/reference/)
  - [CLI reference](https://docs.docker.com/reference/cli/docker/)
  - [Develop with Docker Engine API](https://docs.docker.com/engine/api/)
- [Overview of Docker Desktop](https://docs.docker.com/desktop/)
  - Docker Desktop은 Docker Engine, Docker CLI client, Docker Scout, Docker Build, Docker Extensions, Docker Compose, Docker Content Trust, Kubernetes, Credential  Helper를 포함
  - Docker Engine은 애플리케이션을 빌드하고 컨테이너라이즈하는 컨테이너 기술
  - Docker Scout는 vulnerability에 대한 chain security 강화를 위한 것 [Docker Scout](https://docs.docker.com/scout/)
  - Docker Build는 image 만들기, 코드 패키징 등을 위한 것 [Overview of Docker Build](https://docs.docker.com/build/)
  - Docker Compose multi-container 애플리케이션을 정의하고 실행하기 위한 도구 [Docker Compose overview](https://docs.docker.com/compose/)
- [Docker Engine overview](https://docs.docker.com/engine/)
  - Docker Engine은 client-server 애플리케이션과 같이 동작함
    - dockerd가 daemon process인 server 역할
    - 프로그램들이 daemon과 소통할 수 있는 인터페이스인 APIs
    - docker는 CLI client 역할
      - CLI가 daemon과 상호작용하기 위해 스크립트 혹은 CLI 직접 명령을 통해 Docker APIs를 이용
  - Docker daemon 관련 참고
    - [Windows의 Docker 엔진](https://learn.microsoft.com/ko-kr/virtualization/windowscontainers/manage-docker/configure-docker-daemon)
    - [Start the daemon](https://docs.docker.com/config/daemon/start/)
    - Windows에서는 dockerd 명령어를 통해 Docker daemon을 실행할 수 없는 것으로 알고 있음
    - 하지만 C:\ProgramData\Docker\config\daemon.json 파일을 이용해 Docker daemon 구성을 변경할 수는 있음
  - [Install Docker Engine](https://docs.docker.com/engine/install/) Linex에서 Docker를 사용하고자 한다면 Docker Engine을 설치
    - [Install Docker Engine on Ubuntu](https://docs.docker.com/engine/install/ubuntu/)

## 핵심 정리
### image
- 핵심
  - 애플리케이션 코드와 이를 실행하는 데 필요한 도구, 설정 포함
  - container의 템플릿, 청사진
- 특성
  - layer based architecture
    - Dockerfile의 모든 명령이 image context의 각 layer를 나타냄
    - image 빌드 시 Docker는 모든 명령 결과을 cache, 다시 실행할 필요가 없는 것으로 판단된 명령은 cache된 결과를 사용
    - 변경이 있을 경우 모든 후속 layer에 대해서 캐시 결과를 사용하지 않음
  - read-only
    - 명령이 실행되고 image가 빌드되면 image의 code를 변경할 수 없음
    - 변경이 필요하면 새로운 image 빌드
- image 정보 검사(inspect)
  - docker image inspect \[image id 혹은 image repository 이름\]로 image의 정보 확인 가능
  - image의 full id, 생성 시간, container 구성 정보(노출 포트, 환경 변수, entry point, 사용 OS, layer들 등등)
- image tags
  - name:tag로 구성, name은 repository라고도 함 ex. redis:latest
    - name과 tag를 결합해 unique identifier로 기능함
    - name은 image의 일반적인 이름, 특정 image group을 정의
    - tag는 위 name으로 형성된 특정 image group에서 특정 image를 정의 → 특정 version처럼 사용
### container
- 핵심
  - 소프트웨어 실행 단위 - 애플리케이션과 실행 환경을 포함하는 작은 패키지
  - image의 구체적인 실행 인스턴스
  - container 실행 시 image layer 위에 새로운 container layer를 추가
    - container는 image 위에 추가된 얇은 명령 layer → 실행 중인 container의 size(용량)은 그리 크지 않음
    - 동일한 image를 기반으로 실행되는 여러 container는 image 내부 코드를 공유
- lifecycle
  - 참고 [Lifecycle of Docker Container](https://medium.com/@BeNitinAgarwal/lifecycle-of-docker-container-d2da9f85959)
- attached 모드, detached 모드
  - attached(연결) 모드
    - container를 foreground에서 실행 (cf. docker run으로 실행할 경우 attached 모드가 디폴트)
    - container의 출력 결과를 수신(attach to STDIN, STDOUT or STDERR)
  - detached(분리) 모드
    - container를 background에서 실행 (cf. docker start로 실행할 경우 detached 모드가 디폴트)
- interactive 모드
  - container와 container로 실행 중인 app이 상호작용할 수 있는 모드
  - STDIN을 open으로 유지, attached 모드가 아니어도 상관 없음
  - 주로 pseudo-TTY를 할당하여 터미널을 생성하는 옵션과 함께 실행
### Dockerfile
- 자체 이미지를 빌드할 때 실행하려는 명령이 있는 파일
  - Dockerfile의 각 명령이 image context의 각 layer가 됨
- Dockerfile 작성
  - image 빌드 시 cache를 사용하도록 명령 순서 최적화 필요
  - \(1\) base image 지정
    - FROM [image 이름] → ex. FROM node
    - 보통 Docker 파일 첫 줄이 됨
    - 다른 base image 위에 커스텀 이미지를 구축 ex. OS layer , runtime 환경 같은 것들
    - 로컬 시스템에 있는 image 혹은 Docker Hub 등 registry에 있는 image 이름을 명시
  - \(2\) 작업 경로 지정
    - WORKDIR \[path\] → ex. WORKDIR /app
    - 모든 후속 명령도 해당 경로에서 실행
  - \(3\) 로컬 머신에 있는 파일 복사
    - COPY \[image의 외부 path\] \[path2\] → ex. COPY . ./
      - 첫번째 . → Dockerfile이 위치한 현재 경로를 기준으로 모든 디렉토리, 파일(하위 디렉토리, 파일 포함)을 복사, Dockerfile 자체는 포함하지 않음
      - 두번째 ./
        - 복사한 파일을 저장할 image 내부의 경로, image 및 container는 기본적으로 로컬 머신의 파일 시스템과 완전히 분리된 container 내부 파일 시스템을 가짐
        - ./ 으로 작성하면 WORKDIR로 지정된 경로에 복사, /app으로 명시적으로 작성할 수도 있음
    - image 빌드 시 cache 사용을 위해 일부 파일만 먼저 COPY 하도록 최적화 가능 → ex. COPY package.json /app
  - \(4\) 애플리케이션 빌드, 패키지 설정 등 작업을 위한 image 생성 시 필요 명령 작성
    - RUN \[명령어\]
      - ex. RUN npm install - cf. 시간이 오래 걸리는 작업은 Dockerfile 명령어 순서를 조정하여 cache를 사용할 수 있도록 최적화 필요
  - \(5\) 로컬 시스템과 통신할 포트 설정
    - EXPOSE [포트 번호 숫자] → ex. EXPOSE 80
    - CMD 명령보다 앞에 있어야 함
    - **EXPOSE 유의사항**
      - [Dockerfile reference- EXPOSE](https://docs.docker.com/reference/dockerfile/#expose)
      - EXPOSE: Describe which ports your application is listening on.
      - The EXPOSE instruction doesn't actually publish the port. ... Regardless of the EXPOSE settings, you can override them at runtime by using the -p flag.
      - EXPOSE는 문서화할 뿐임,  실제 포트 노출은 docker run -p 옵션을 통해 진행됨
  - \(6\) image를 바탕으로 container 시작 시 필요 명령 작성
    - CMD \[명령어를 위한 문자열 배열\] → ex. CMD \["node", "server.js"\]
    - CMD가 없는 경우 단지 base image가 실행됨
- Dockerfile 기반으로 커스텀 image 생성
  - docker build [Dockerfile이 있는 경로] → ex. docker build .
  - 빌드된 커스텀 image를 container로 실행하는 방법은 아래 Docker CLI 주요 명령어 중 run 부분 참고
- .dockerignore 파일
  - Dockerfile의 COPY 명령에서 복사해서는 안 되는 파일, 디렉토리 지정 가능
    - 마치 git에서 .gitignore 파일의 역할과 유사
- build-time에 사용할 ARGuments와 runtime에 사용할 ENVironment variables
  - ARG
    - Dockerfile에서는 ARG 명령어로 설정
    - docker build 시 --build-arg 옵션 사용
  - ENV
    - Dockerfile에서는 ENV 명령어로 설정
    - container 시작 시 -e 혹은 --env 옵션 사용, 파일에서 불러올 경우 --env-file 옵션 사용

#### ARG와 ENV
- 하드 코딩된 값 대신 ARG, ENV로 동적으로 부여된 값을 이용해 유연한 image, container를 만들 수 있음
- (ENV) runtime environment variable → image를 rebuild 하지 않고 환경 변수 값을 설정하여 보다 유연하게 container 구성 가능
  - [명령어 관련 공식 문서](https://docs.docker.com/reference/dockerfile/#env)
  - runtime에 application에서도 사용 가능한 값
  - 방법 1. Dockerfile에 명시
    - (정의 방법) ENV \[key\] \[value\] 형태
    - (사용 방법) 정의된 값을 사용할 때는 $\[ key\] 형태로 불러와서 사용
  - 방법 2. container 시작 시 -e 혹은 --env 옵션 사용
    - (사용 방법) container 시작 시 옵션으로 --env \[key\]=\[value\] 부여
      - Dockerfile에 동일한 key의 environment variable이 있었을 경우, run할 때 부여한 value로 덮어 씀
      - --env 대신 -e로도 가능
      - 여러 개의 -v flag를 줄 수 있었듯이 여러 개의 -e flag로 여러 환경 변수 부여 가능
  - 방법 3. environment variable을 위한 별도 파일 작성, container 시작 시 --env-file 옵션 사용
    - 사용 방법
      - (관례적으로) .env 파일 사용
      - 파일에 \[key\]=\[value\] 형태로 여러 환경 변수를 지정
      - container 시작 시 --env-file \[.env 파일이 있는 경로\]/.env 옵션 추가
    - 환경 변수를 위한 별도 파일을 작성함으로써 보안 데이터 유출을 막을 수 있음
      - Dockerfile에 환경 변수를 포함시키면 docker history를 통해 이를 읽을 수 있음
      - 특히 자격 증명, 개인 키 등은 노출되지 않도록 유의
      - 별도 환경 변수 파일을 사용할 때도, 형상 관리 시 커밋되지 않도록 유의
- (ARG) build-time arguments → Dockerfile을 변경하지 않고 다른 argument를 부여하여 보다 유연하게 image build 가능
  - [명령어 관련 공식 문서](https://docs.docker.com/reference/dockerfile/#arg)
  - Docker image의 build-time에 사용되는 값이므로 Dockerfile의 CMD 명령어 및 source code에서는 ARG에 정의된 값을 사용할 수 없음에 유의
  - 방법 1. Dockerfile에 명시
    - (정의 방법) ARG \[key\]=\[value\] 형태
      - Dockerfile의 ENV와 다르게 ARG 정의 시에는 "="가 들어감의 유의
    - (사용 방법) 정의된 값을 Dockerfile 내에서 사용할 때는 $\[key\] 형태로 불러와서 사용
  - 방법 2. image build 시 --build-arg 옵션으로 명시
    - (사용 방법) image build 시 옵션으로 --build-arg \[key\]=\[value\] 부여
### image 공유
- container를 공유하지 않고 image를 공유, 공유된 image를 기반으로 container를 실행
- cf. Dockerfile 공유
  - Dockerfile과 함께 app의 source code를 제공, 공유된 파일을 이용해 image 빌드
  - Dockerfile의 위치를 중심으로 모든 파일과 디렉토리 구조까지 공유되어야 함
- 빌드된 image 공유
  - image를 다운(pull)받고 container를 실행하기만 하면 됨
  - image 자체를 공유할 때는 1. Docker Hub 혹은 2. Private Registry 이용
- registry: image 공유 위치
  - (1) Docker Hub: official Docker image registry
    - public, private, offical image들 존재
  - (2) private registry: Docker Hub 외에도 다양한 provider 존재
- 빌드된 image 공유 방법
  - (공유 시) docker push \[image 이름\]
  - (사용 시) docker pull \[image 이름\]
  - 공유를 위해선 먼저 registry에 image의 repository를 생성해두어야 함
    - registry의 repository와 일치하는 이름을 가진 local registry가 있어야 함
    - 즉 image의 이름이 registry repository와 같은 image가 있어야 함
  - private registry에서 image를 공유하고자 할 경우 \[provider url:image 이름\]과 같은 방식으로 host까지 명시해줘야 함
  - 참고 사항
    - push 할 때는 의존하고 있는 base image까지 함께 업로드 되진 않음
      - base image에 대한 연결을 설정하고, 추가 정보만 push
    - tag를 명시하지 않으면 latest tag를 자동으로 부여
### volume과 Docker external data storage
- volumes → directories on host machine which are mounted(or made available or mapped) into containers
  - container 외부의 특정 디렉토리에 연결된 Docker container 내부 디렉토리/파일
  - container가 volume을 mount하면 해당 volume의 data를 container에서 사용 가능
    - 사용 방식에 따라 container에서 volume에 data을 read, write 할 수 있고, 영속성이 필요한 data를 둘 수도 있음
- Docker의 external data storage
  - (external data storage를 이용하는 세 가지 방법) anonymous volume, named volume, bind mount
    - (세 방법의 공통점) container에서 정의된 경로가 host machine의 volume에 mounted(host machine 특정 경로에 mapped/mirrored) 
      - cf .anonymous volume이라고 해서 volume의 data가 host machine에 저장되지 않는 게 아님
  - (1) volume → managed by Docker
    - anonymous volume, named volume의 공통점
      - volume은 Docker에 의해서 관리됨
        - Docker에 의해 관리되므로 container 시작 시 volume이 존재하지 않으면 이를 생성함
      - host machine에 mapping된 정확한 경로를 찾기 어려우며, docker volume 명령을 통해서만 접근 가능, 직접 access 불가
    - (1-1) anonymous volume
      - (사용 방법) docker run -v /app/data ... 혹은 Dockerfile에 VOLUME 명령어 추가
      - 하나의 특정 container와만 연결될 것으로 예상하고 생성하는 volume으로 생각하면 될 것
        - container 시작 시 --rm 옵션을 준 경우, container 중지하면 container와 volume 함께 제거
        - **container 간 data 공유 불가, 같은 image를 사용하더라도 volume 재사용 불가**
        - **container에 이미 존재하는 특정 data를 수정할 수 없도록 하는 데에 유용함**
    - (1-2) named volume
      - (사용 방법) docker run -v volume-name:/app/data ...
      - 여러 container(특히 중지되고 다시 시작되는 container들)와 연결될 것을 염두에 두고 생성되는 volume
        - container 시작 시 --rm 옵션을 준 경우, container 제거 후에도 volume 유지
        - **volume 재사용 가능 → 영속성이 필요하지만, 직접 수정할 필요는 없는 data인 경우 사용**
        - **여러 container 간 data 공유 가능**
  - (2) bind mount → managed by user
    - (사용 방법) docker run -v /absolute/path/in/host/machine:/app/code ...
    - 명시한 container 내부 경로가 host machine에 mapping된 정확한 경로를 명시
      - container 제거 후에도 유지 → **영속성이 필요한 data**
        - Docker 명령어로는 bind mount의 data 삭제 불가, host의 file system에서 data를 직접 삭제 해야 함
      - bind mount에 있는 data를 수정 가능 → **container 내부 mapping된 경로에 있는 data\(source code까지도\) 수정 가능\(live data\)**
      - **여러 container 간 data 공유 가능**
    - cf. Docker Desktop을 사용한다면 Preferences → Resources → FILE SHARING에서 mount 가능한 host machine 경로 설정이 필요할 수 있음
      - 경로를 작성할 때 Linux에서는 -v $(pwd):/app, Windows에서는 -v "%cd%":/app과 같은 방식으로 바로 가기를 사용할 수 있음
  - 자세한 사용 예시는 아래 "Docker의 데이터 관리 및 volume 작업 → Docker external data storage를 이용한 permanent app data 작업"을 참고
  - 유의 사항
    - Docker container가 시작될 때 bind mount하면 Docker가 host machine의 local 경로를 덮어쓰지는 않지만,
      - container 내부의 경로가 host machine의 bind mount 경로 내용으로 덮어씌워짐에 유의
    - 이 문제를 해결하기 위해 mapping하기로 한 container 내부 경로 중 외부 내용으로 덮어쓰면 안 되는 부분이 있음을 알려줘야 함 ex. anonymous volume 활용
    - Docker는 volume 설정 간 충돌하는 부분이 있는 경우, 내부 경로가 더 구체적인 volume 설정을 우선 적용함
  - 참고 자료
    - [Understanding Docker Volumes: Anonymous Volumes, Named Volumes, and Bind Mounts](https://medium.com/@kavindumadushanka972/understanding-docker-volumes-anonymous-volumes-named-volumes-and-bind-mounts-bdae3af94330)
    - [Docker 컨테이너에 데이터 저장 (볼륨/바인드 마운트)](https://www.daleseo.com/docker-volumes-bind-mounts/)

## Docker CLI 주요 명령어 및 그 옵션
- --help
  - (모든 Docker CLI 명령어 확인) docker --help
    - cf. 예전에 사용했으나, 현재는 더 나은 명령어가 나왔기에 거의 사용할 일이 없는 명렁어도 있음
  - (특정 명령어의 옵션 확인) docker \[명령어\] --help → 해당 명령어에 대한 모든 옵션 확인
- push → image 업로드
  - (사용 방법) docker push \[image 이름\]
    - (private registry를 사용할 경우) docker push \[provider url:image 이름\]
- push → image 다운로드
  - (사용 방법) docker pull \[image 이름\]
    - (private registry를 사용할 경우) docker pull \[provider url:image 이름\]
- build → Dockerfile을 기반으로 image 빌드
  - (사용 방법) docker build .
  - \(-t flag 혹은 --tag \[list\]\) 빌드할 image에 name:tag 형식으로 image tag 부여
    - ex. docker build -t goals:1 .
    - cf. 만약 이미 존재하는 image의 이름을 변경하고자 한다면 tag 명령어를 사용
  - \(--build-arg \[key\]=\[value\]\) 빌드 시 ARG 값 부여 혹은 재정의
- tag → 이미 존재하는 image의 image tag(image 이름, repository)를 변경
  - (사용 방법) docker tag \[image의 현재 이름\] \[변경하고자 하는 이름\]
  - cf. 이전 image는 제거되지 않고, 변경된 이름을 가진 복제본 생성
- login → registry에 로그인
  - (사용 방법) docker login 입력 후 프롬프트에 따라 Username, Password 입력
    - (옵션을 이용해 Username, Password 입력) docker login -u \[Username\] -p \[Password\]
    - (다른 registry에 로그인할 경우) docker login \[registry url\]
  - cf. docker logout으로 registry에서 로그아웃 가능
- run
  - (사용 방법) docker run \[image name\] → image를 기반으로 새 컨테이너를 생성
    - run으로 다른 옵션 없이 container을 생성 및 시작할 경우 attached - 터미널에서 blocked(foreground 실행)
    - 이 상태에서 ctrl + c를 입력할 경우 status가 Exited가 됨
    cf. local에 image가 없는 경우 registry에서 자동으로 pull → image가 있다면 image를 업데이트하진 않는다는 의미이기도 함
  - \(-p flag 혹은 --publish \[list\]\) 로컬 머신의 어떤 포트가 container의 특정 포트에 접근하는데 사용되는지 명시 
    - -p \[app에 접근하려는 로컬 포트\]:[내부 container 노출 포트] → ex. -p 3000:80
  - \(-d flag\) detached 모드로 실행
  - \(-i flag 혹은 --interactive\) open STDIN - interactive 모드로 실행
  - \(-t flag 혹은 --tty\) pseudo-TTY 할당
  - \(--rm flag\) container를 중지할 때 제거되도록 함
  - \(--name flag \[string\]\) container에 이름을 부여
  - \(-e flag 혹은 --env \[key\]=\[value\]\) container runtime 환경에서 사용할 환경 변수 부여
  - \(--env-file \[.env 파일이 있는 경로\]/.env\) container runtime 환경에서 사용할 환경 변수를 .env 파일에서 읽어서 사용
- start
  - (사용 방법) docker start \[container name 혹은 containter id\] → status가 Exited인 container를 다시 시작
    - start로 다른 옵션 없이 재시작할 경우 detached - 터미널에서 blocking하지 않음(background 실행)
  - \(-a flag\) attached 모드로 실행 → STDOUT/STDERR와 연결하는 것
    - 이 상태에서 ctrl + c를 입력할 경우 status가 Exited가 되지 않고 Up으로 계속 실행
  - \(-i flag 혹은 --interactive\) open STDIN
    - docker start d-ai .. 로 container에 attached되며 interactive 작업 가능해짐
- attach
  - (사용 방법) docker attach \[container name 혹은 containter id\] → detached 모드로 시작된 container에 attach
    - 이 상태에서 ctrl + c를 입력할 경우 status가 Exited가 됨
- logs
  - (사용 방법) docker logs \[container name 혹은 containter id\] → 해당 container의 로그 확인
  - \(-f flag 혹은 --follow\) Follow log output - 로그 출력 수신 대기, 앞으로 출력되는 로그도 확인하도록 연결
- rm → containter를 제거
  - (사용 방법) docker rm \[container name 혹은 containter id\]
    - 다음과 같이 여러 container를 한 번에 제거할 수도 있음
    - docker rm \[container name 혹은 containter id\] \[container name 혹은 containter id\] ...
    - 실행 중인 container는 기본 rm으로 제거 불가능, stop 후 제거 가능
  - cf. container prune → 중지된 모든 container를 제거
    - (사용 방법) docker container prune
    - cf. docker prune으로는 실행할 수 없음, management command인 container를 꼭 붙여야 함
- rmi → image를 제거, 기본적으로 image 내부의 모든 layer를 함께 제거
  - (사용 방법) docker rmi \[image id\]
      - 다음과 같이 여러 image를 한 번에 제거할 수도 있음
      - docker rmi \[image id\] \[image id\] ...
  - 현재 container에서 사용되지 않는 image만 제거 가능, 중지된 container에서 사용 중인 image도 제거 불가
  - cf. images → 갖고 있는 모든 image 목록 확인
    - (사용 방법) docker images
  - cf. image prune → 사용되지 않는 모든 image들 제거
    - (사용 방법) docker image prune
- image inspect → image에 대한 정보 출력
  - (사용 방법) docker image inspect \[image id 혹은 image repository 이름\]
- cp → 실행 중인 container와 local host machine 간 파일 복사
  - (사용 방법) docker cp \[source 파일 혹은 디렉토리\] \[destination 경로\]
    - 디렉토리에 있는 모든 것을 복사하려면 \[디렉토리 경로\] 혹은 \[디렉토리 경로/.\]으로 입력
    - container가 대상인 경로 쪽에 container name을 명시 ex. local-redis:/app (cf. 마치 C:/Users 같은 느낌)
    - destination 경로가 존재하지 않으면 생성함
    - ex1. docker cp dummy/. local-redis:/app
    - ex2. docker cp local-redis:/app/test.txt test
  - 오류 발생 가능성 때문에 대체로 사용하지 않는 편이 좋겠지만
    - web server 구성 파일 변경, 로그 파일 복사 등 간단한 작업에 사용해볼 수 있음
- (management command) volume
  - volume ls → 현재 존재하는 volume 목록\(list\) 확인
    - (사용 방법) docker volume ls
    - cf. bind mount는 Docker에 의해 관리되는 volume이 아니므로 목록에 나오지 않음
  - volume create → volume 생성
    - (사용 방법) docker volume create \[volume 이름\]
    - 하지만 수동으로 volume을 생성해두어야할 경우는 많지 않을 것
  - volume prune → 사용되지 않는 모든 local volume 제거
  - volume rm → 명시한 volume 제거
    - (사용 방법) docker volume rm \[volume 이름\] \[volume 이름\] ...
  - volume inspect → volume에 대한 자세한 정보 출력
    - (사용 방법) docker volume inspect \[volume 이름\] \[volume 이름\] ...
      - 옵션으로 -f \[template 이름\]을 줄 경우 특정 format으로 출력 가능 - [참고](https://docs.docker.com/go/formatting/)
    - CreatedAt, Driver, Name, Mountpoint, Options\(읽기 전용 여부 등 옵션\) 등 표시
      - (mountpoint) 실제로 data가 저장되는 host machine 상 경로
        - Docker가 생성한 volume이 있는 위치, 하지만 host machine 파일 시스템 상에서 실제로 확인할 수는 없음    

## Docker의 data 관리 및 volume 작업
- [Docker Engine의 storage 관련 공식 문서 참고 자료](https://docs.docker.com/storage/)
### Docker에서 다루는 data의 종류와 해결 과제
- Docker에서 다루는 data의 종류
  - (1) application(source code + environment)
    - image 빌드 시 image에 복사되는 data
    - image가 빌드되면 변경 불가(read-only)
    - image에 저장된 data
  - (2) temporary app data
    - app이 실행되는 동안 container에서 생성되는 data, 읽고 쓰기 가능
    - 없어져도 괜찮은 data → memory, 임시 파일 등으로 저장
    - container에 저장된 data → image 위에 있는 container를 구성하는 layer
  - (3) permanent app data
    - app이 실행되는 동안 container에서 생성되는 data, 읽고 쓰기 가능
    - 지속되어야 하는 data → DB, 파일 형태로 저장
      - container가 중지, 재시작, 제거 되더라도 남아야 하는 data
    - container에 저장되지만, volume의 도움을 받아야 함
- 해결 과제: Docker container의 data 문제
  - 기본적으로 local(host machine) file system과 container 혹은 image는 연결되어 있지 않음
  - Dockerfile로 image를 빌드할 시점의 파일 및 디렉토리가 일종의 snapshot이 된다고 생각할 수 있음
  - container 내부 file system과 host machine의 local file system은 별개
    - container 내부 file system은container을 stop해도 사라지지는 않음
    - 당연히 image 기반으로 구축된 application source code 등도 사라지지 않음
    - 하지만 container를 제거하면 container의 모든 data 제거
  - container layer는 read, write 가능이지만, image layers는 read-only
    - container layer의 data 변경 사항은 image layer에 반영되지 않음
    - 단지 container layer의 read-write 가능 layer에 저장될 뿐
### Docker external data storage를 이용한 permanent app data 작업
- 영속성이 필요한 data, bind mount로 덮어씌워지면 안 되는 data를 고려하여 anonymous volume, named volume, bind mount를 적절히 함께 사용
  - 유의 사항
    - Docker container가 시작될 때 bind mount하면 Docker가 host machine의 local 경로를 덮어쓰지는 않지만,
    - container 내부의 경로가 host machine의 bind mount 경로 내용으로 덮어씌워짐에 유의
  - anonymous volume를 사용하는 예시 → 영속성이 없음
    - (ex. Dockerfile 명령어 예시) VOLUME [ "/app/feedback" ]
    - (ex. Docker CLI 명령어 예시) container 시작 시 -v /app/feedback 옵션 추가
  - named volume을 사용하는 예시 → data를 수정할 수 없음
    - (ex. Docker CLI 명령어 예시) docker run -d -p 3000:80 --rm --name feedback-app -v feedback:/app/feedback feedback-node:volumes
  - bind mount를 사용하는 예시 → bind mount mapping된 host machine 경로의 data가 덮어씌워져서 container의 app이 실행되지 않을 수 있음
    - (ex. Docker CLI 명령어 예시) docker run -d -p 3000:80 --rm --name feedback-app -v "C:\docker-kubernetes-example\docker-volume-example":/app feedback-node:volumes
  - 위 세 external data storage를 함께 사용하는 예시
    - (ex. Docker CLI 명령어 예시) docker run -d -p 3000:80 --rm --name feedback-app -v "/mnt/c/docker-kubernetes-example/docker-volume-example":/app -v feedback:/app/feedback -v /app/node_modules feedback-node:volumes
      - cf. host machine의 절대 경로 전체를 큰 따옴표로 묶어도 됨, 특히 공백, 특수 문자가 있는 경우 필요할 것 ex.  "~/volume-ex"
      - mapping하기로 한 container 내부 경로 중 host machine의 bind mount 경로의 내용으로 덮어쓰면 안 되는 부분을 제외하기 위해 anonymous volume을 활용한 것
        - Docker는 volume 설정 간 충돌하는 부분이 있는 경우, 내부 경로가 더 구체적인 volume 설정을 우선 적용
        - 즉 위 예시의 경우 /app/node_modules에 mapping되는 곳은 bind mount를 위해 지정된 local 경로가 아닌 anonymous volume  
          → /app/node_modules가 host의 bind mount 경로의 내용물로 덮어쓰여지지 않게 하는 것
- Docker를 활용하면서 편리한 개발 환경 구축하기
  - bind mount까지 적용했다면 image를 다시 build 하지 않아도 source code 변경사항을 app에서 확인 가능
    - app의 source code를 host machine의 bind mount 경로에 두고, 이 source code를 변경하면 app에서 변경 사항 확인 가능
    - node.js 서버의 경우 nodemon 라이브러리 사용하면 편리 → souce code 변경사항이 바로 app에 반영
      - package.json에 devDependencies로 nodemon 추가 및 "npm start" script 설정
      - Docker file에서 CMD 변경 후 image 다시 빌드하여 라이브러리 추가 내용 반영
      - cf. Windows OS에서 WSL2를 host machine으로 사용하면서 Windows 파일 시스템에 있는 파일을 변경 중이라면 파일 변경 전파의 문제로 nodemon이 동작하지 않을 수 있음
        - (참고) [Access Linux filesystems in Windows and WSL 2](https://devblogs.microsoft.com/commandline/access-linux-filesystems-in-windows-and-wsl-2/), [Docker Desktop: WSL 2 Best practices](https://www.docker.com/blog/docker-desktop-wsl-2-best-practices/)
        - 단순하지만 지저분한 방법으로는 nodemon을 -L 옵션으로 시작할 수 있음 → [nodemon 공식 문서 참고 ](https://github.com/remy/nodemon?tab=readme-ov-file#application-isnt-restarting)
    - nodemon 같은 라이브러리를 사용하지 않으면, image 빌드는 하지 않더라도 source code 변경사항 적용을 위해 container 재시작 필요
  - cf. 이렇게 bind mount를 이용하여 source code 변경 사항을 바로 반영하는 방식은 개발 환경에서 사용하는 것
    - 운영 환경에서는 코드의 snapshot을 이용하지, 실시간으로 변경되는 source code를 이용하지 않음 → Dockerfile에서 COPY 명령어는 여전히 필요함
- 읽기 전용 external data storage
  - container 쪽에서는 external data storage의 data를 읽기만 가능하게 하려면 :ro를 추가
    - ex. -v "/mnt/c/docker-kubernetes-example/docker-volume-example":/app:ro
      - (전체 명령어) docker run --rm -d -p 3000:80 --name feedback-app -v "/mnt/c/docker-kubernetes-example/docker-volume-example":/app:ro -v feedback:/app/feedback -v /app/node_modules feedback-node:volumes
    - 그 하위 경로까지 수정할 수 없게 함, 하지만 하위 경로이더라도 더 구체적으로 명시된 write 가능 volume이 있다면 수정 가능

## Docker container의 통신
- [Docker Engine의 networking 관련 공식 문서 참고 자료](https://docs.docker.com/network/)
- conatiner에서 가능한 통신의 종류
  - 1. container와 web 간 통신
  - 2. container와 host machine 간 통신
  - 3. container와 다른 container 간 통신
